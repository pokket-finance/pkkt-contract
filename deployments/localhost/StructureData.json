{
  "address": "0xB06c856C8eaBd1d8321b687E188204C1018BC4E5",
  "abi": [
    {
      "inputs": [],
      "name": "MATUREROUND",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xc11e1e69c95cf3726f64df1e70187f073b5eea1a8d6629b1884686c3c3779124",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xB06c856C8eaBd1d8321b687E188204C1018BC4E5",
    "transactionIndex": 0,
    "gasUsed": "83666",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xbadadecc9d47d347de2de7becff57ac4668b47b809ecf0e800bb1f1535209d38",
    "transactionHash": "0xc11e1e69c95cf3726f64df1e70187f073b5eea1a8d6629b1884686c3c3779124",
    "logs": [],
    "blockNumber": 13600146,
    "cumulativeGasUsed": "83666",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "3ecf9754b966a91ca355dcd053ab70bf",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MATUREROUND\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/StructureData.sol\":\"StructureData\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8666f020bd8fc9dc14f07e2ebc52b5f236ab4cdde7c77679b08cb2f94730043b\",\"license\":\"MIT\"},\"contracts/libraries/StructureData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport './Utils.sol';\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nlibrary StructureData {\\n     \\n    using SafeMath for uint256;\\n     uint8 public constant MATUREROUND= 1; //7 for daily settlement, 1 for daily settlement\\n     using Utils for uint256;\\n     struct OptionParameters {\\n         address option;\\n         uint256 strikePrice;  // strike price if executed\\n         uint8 pricePrecision;\\n         uint16 premiumRate; //take, 0.01% is represented as 1, precision is 4\\n     }\\n\\n    struct OptionState {\\n         uint256 round;\\n         uint256 totalAmount; \\n         uint256 totalTerminate;   \\n         uint256 strikePrice; \\n         uint16 premiumRate; //take, 0.01% is represented as 1, precision is 4\\n         uint8 pricePrecision; \\n         bool executed; \\n         bool callOrPut; //call for collateral -> stablecoin; put for stablecoin->collateral;\\n    }\\n \\n   struct MaturedState {\\n       uint256 releasedDepositAssetAmount;\\n       uint256 releasedDepositAssetPremiumAmount;\\n       uint256 releasedCounterPartyAssetAmount; \\n       uint256 releasedCounterPartyAssetPremiumAmount; \\n       uint256 autoRollDepositAssetAmount;\\n       uint256 autoRollDepositAssetPremiumAmount;\\n       uint256 autoRollCounterPartyAssetAmount; \\n       uint256 autoRollCounterPartyAssetPremiumAmount; \\n\\n       uint256 round;\\n       \\n   }\\n\\n    enum OptionType {\\n        HodlBooster,\\n        VolAlpha\\n    }\\n\\n    struct UserState {\\n        uint256 pendingAsset; //for current round\\n        uint256 tempLocked;//asset not sent to trader yet, but closed for deposit\\n        uint256[MATUREROUND] ongoingAsset; //for previous 7 rounds\\n        uint8 nextCursor; //nextCursor\\n        uint232 totalRound; \\n        bool hasState;\\n        uint256 assetToTerminate;  \\n        uint256 assetToTerminateForNextRound;  \\n    }\\n\\n    struct OptionSnapshot {\\n        uint256 totalPending;\\n        uint256 totalLocked;\\n        uint256 totalReleasedDeposit;\\n        uint256 totalReleasedCounterParty; \\n    }\\n\\n    struct UserBalance {\\n        uint256 pendingDepositAssetAmount; \\n        uint256 lockedDepositAssetAmount;  \\n        uint256 releasedDepositAssetAmount;\\n        uint256 releasedCounterPartyAssetAmount;\\n    }\\n\\n    function SetOngoingAsset(UserState storage userState, uint256 newValue) internal { \\n        uint cursor = userState.nextCursor;\\n        userState.ongoingAsset[cursor] = newValue;\\n        uint8 nextCursor = cursor == (MATUREROUND - 1) ? uint8(0) : uint8(cursor + 1);\\n        userState.nextCursor = nextCursor;\\n        userState.totalRound = userState.totalRound + 1; //won't overflow\\n    }\\n    \\n    function GetOngoingAsset(UserState storage userState, uint8 backwardRound) internal view returns(uint256) {\\n        if (userState.totalRound <= backwardRound) return 0;\\n        require(backwardRound < MATUREROUND);\\n        int8 previousCursor = int8(userState.nextCursor) - int8(backwardRound) - 1;\\n        if (previousCursor < 0) {\\n            previousCursor = previousCursor + int8(MATUREROUND);\\n        }\\n        return userState.ongoingAsset[uint8(previousCursor)];\\n    }\\n\\n    function deriveWithdrawRequest(UserState storage userState, uint256 premiumRate) internal view returns (uint256 _onGoingRoundAmount, uint256 _lockedRoundAmount) {\\n       if (userState.tempLocked == 0) {\\n           return (userState.assetToTerminateForNextRound, 0);\\n       }\\n       uint256 onGoing = GetOngoingAsset(userState, 0);\\n       if (onGoing == 0) {\\n           return (0, userState.assetToTerminateForNextRound);\\n       }\\n       onGoing = onGoing.sub(userState.assetToTerminate);\\n       uint256 virtualOnGoing = onGoing.withPremium(premiumRate);\\n       if (userState.assetToTerminateForNextRound <= virtualOnGoing) {\\n           return (userState.assetToTerminateForNextRound, 0);\\n       }\\n       else {\\n           return (virtualOnGoing, userState.assetToTerminateForNextRound.sub(virtualOnGoing));\\n       }\\n    }\\n    function deriveVirtualLocked(UserState storage userState, uint256 premiumRate) internal view returns (uint256) {\\n        uint256 onGoing = GetOngoingAsset(userState, 0);\\n        if (onGoing == 0) {\\n            return userState.tempLocked;\\n        }\\n        onGoing = onGoing.sub(userState.assetToTerminate);\\n        if (userState.tempLocked == 0) {\\n            return onGoing.withPremium(premiumRate);\\n        }\\n        return userState.tempLocked.add(onGoing.withPremium(premiumRate));\\n        \\n    }\\n    struct OptionPairDefinition{\\n        address callOption;\\n        address putOption;\\n        address callOptionDeposit;\\n        address putOptionDeposit;\\n    }\\n    struct SettlementAccountingResult {\\n        //won't change regardless execute or not\\n        address option;\\n        uint256 round;\\n        uint256 depositAmount;  \\n\\n        //following will change if execute or not\\n        bool executed;\\n        uint256 autoRollAmount; //T-1 Carried (filled only when not executed)\\n        uint256 autoRollPremium; //Premium (filled only when not executed)\\n        //maturedAmount+maturedPremium = requested withdrawal for deposit asset(filled only when not executed and with withdraw request)\\n        uint256 releasedAmount;  \\n        uint256 releasedPremium;\\n        //autoRollCounterPartyAmount + autoRollCounterPartyPremium = Execution rolled-out for deposit asset (Execution roll-in for counter party option)\\n        //filled only when executed\\n        uint256 autoRollCounterPartyAmount;\\n        uint256 autoRollCounterPartyPremium;\\n        //maturedCounterPartyAmount+maturedCounterPartyPremium= requested withdrawal for couter party asset(filled only when executed and with withdraw request)\\n        uint256 releasedCounterPartyAmount;\\n        uint256 releasedCounterPartyPremium; \\n\\n    }\\n\\n    enum OptionExecution{\\n        NoExecution,\\n        ExecuteCall,\\n        ExecutePut\\n    }\\n\\n    struct OptionPairExecutionAccountingResult {  \\n        SettlementAccountingResult callOptionResult;\\n        SettlementAccountingResult putOptionResult;\\n        OptionExecution execute;\\n    }\\n\\n    struct OptionPairExecution {\\n        address callOption;\\n        address putOption;\\n        OptionExecution execute; \\n    }\\n\\n    \\n\\n    struct SettlementCashflowResult{ \\n        address contractAddress; //0 for eth \\n        uint256 newDepositAmount;\\n        uint256 newReleasedAmount;\\n        int256 leftOverAmount; //positive, if trader didn't withdraw last time; negative, if trader failed to send back last time; \\n    }\\n \\n}\",\"keccak256\":\"0xe0c9893fc41b61f4cb2462dc918ba27e94f2f846aba8e43f07130eaf80daa797\",\"license\":\"MIT\"},\"contracts/libraries/Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nlibrary Utils { \\n     \\n \\n      uint256 public constant RATIOMULTIPLIER = 10000;\\n     using SafeMath for uint256;\\n      function StringConcat(bytes memory _base, bytes memory _value) internal pure returns (string memory) {\\n        string memory _tmpValue = new string(_base.length + _value.length);\\n        bytes memory _newValue = bytes(_tmpValue);\\n\\n        uint i;\\n        uint j;\\n\\n        for(i=0; i<_base.length; i++) {\\n            _newValue[j++] = _base[i];\\n        }\\n\\n        for(i=0; i<_value.length; i++) {\\n            _newValue[j++] = _value[i++];\\n        }\\n\\n        return string(_newValue);\\n    }\\n\\n    function Uint8Sub(uint8 a, uint8 b) internal pure returns (uint8) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n \\n   function getAmountToTerminate(uint256 _maturedAmount, uint256 _assetToTerminate, uint256 _assetAmount) internal pure returns(uint256) {\\n       if (_assetToTerminate == 0 || _assetAmount == 0 || _maturedAmount == 0) return 0;\\n       return _assetToTerminate >= _assetAmount ?  _maturedAmount : _maturedAmount.mul(_assetToTerminate).div(_assetAmount);\\n   }\\n\\n   function withPremium(uint256 _baseAmount, uint256 _premimumRate) internal pure returns(uint256) {\\n       return _baseAmount.mul(RATIOMULTIPLIER.add(_premimumRate)).div(RATIOMULTIPLIER);\\n   }\\n   \\n   function premium(uint256 _baseAmount, uint256 _premimumRate) internal pure returns(uint256) {\\n       return _baseAmount.mul(_premimumRate).div(RATIOMULTIPLIER);\\n   }\\n   \\n\\n}\",\"keccak256\":\"0x6bae4b85176e81817159abf8d873b71c7df35bdf7ba35f3991e992045d408467\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608b610038600b82828239805160001a607314602b57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f747e177146038575b600080fd5b603f600181565b60405160ff909116815260200160405180910390f3fea2646970667358221220ddcec76055e9a78bb6785497a3046713cd83e945a94b07e162622f5a5a86089664736f6c63430008040033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f747e177146038575b600080fd5b603f600181565b60405160ff909116815260200160405180910390f3fea2646970667358221220ddcec76055e9a78bb6785497a3046713cd83e945a94b07e162622f5a5a86089664736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}