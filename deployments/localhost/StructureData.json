{
  "address": "0xd9fEc8238711935D6c8d79Bef2B9546ef23FC046",
  "abi": [
    {
      "inputs": [],
      "name": "MATUREROUND",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "OPTION_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SETTLER_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x037001d359a880e18026d5483f6b896d3e3092eecdfb5621a025d6b2f1c8e48b",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xd9fEc8238711935D6c8d79Bef2B9546ef23FC046",
    "transactionIndex": 0,
    "gasUsed": "107451",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5e56007a947a0e24b287b164022ee0f1b24a68967b6c463a34f42f6ae5dd093c",
    "transactionHash": "0x037001d359a880e18026d5483f6b896d3e3092eecdfb5621a025d6b2f1c8e48b",
    "logs": [],
    "blockNumber": 13600293,
    "cumulativeGasUsed": "107451",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "4d1fa2e9fd4fdb5284870d53517b87d0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MATUREROUND\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPTION_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SETTLER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/StructureData.sol\":\"StructureData\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8666f020bd8fc9dc14f07e2ebc52b5f236ab4cdde7c77679b08cb2f94730043b\",\"license\":\"MIT\"},\"contracts/libraries/StructureData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport './Utils.sol';\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nlibrary StructureData {\\n     \\n    using SafeMath for uint256;\\n    \\n    bytes32 public constant OPTION_ROLE = keccak256(\\\"OPTION_ROLE\\\");\\n    bytes32 public constant SETTLER_ROLE = keccak256(\\\"SETTLER_ROLE\\\");\\n     uint8 public constant MATUREROUND= 1; //7 for daily settlement, 1 for daily settlement\\n     using Utils for uint256;\\n     struct OptionParameters {\\n         uint256 strikePrice;  // strike price if executed\\n         address option;\\n         uint8 pricePrecision;\\n         uint16 premiumRate; //take, 0.01% is represented as 1, precision is 4\\n     }\\n\\n    struct OptionState {\\n         uint256 round;\\n         uint256 totalAmount; \\n         uint256 totalTerminate;   \\n         uint256 strikePrice; \\n         uint16 premiumRate; //take, 0.01% is represented as 1, precision is 4\\n         uint8 pricePrecision; \\n         bool executed; \\n         bool callOrPut; //call for collateral -> stablecoin; put for stablecoin->collateral;\\n    }\\n \\n   struct MaturedState {\\n       uint256 releasedDepositAssetAmount;\\n       uint256 releasedDepositAssetPremiumAmount;\\n       uint256 releasedCounterPartyAssetAmount; \\n       uint256 releasedCounterPartyAssetPremiumAmount; \\n       uint256 autoRollDepositAssetAmount;\\n       uint256 autoRollDepositAssetPremiumAmount;\\n       uint256 autoRollCounterPartyAssetAmount; \\n       uint256 autoRollCounterPartyAssetPremiumAmount; \\n\\n       uint256 round;\\n       \\n   }\\n\\n    enum OptionType {\\n        HodlBooster,\\n        VolAlpha\\n    }\\n\\n    /*struct UserState {\\n        uint256 pendingAsset; //for current round\\n        uint256 tempLocked;//asset not sent to trader yet, but closed for deposit\\n        uint256[MATUREROUND] ongoingAsset; //for previous 7 rounds\\n        uint256 assetToTerminate;  \\n        uint256 assetToTerminateForNextRound;  \\n        uint8 nextCursor; //nextCursor\\n        uint232 totalRound; \\n        bool hasState;\\n    }*/\\n\\n    struct UserState {\\n        uint256 pendingAsset; //for current round\\n        uint256 tempLocked;//asset not sent to trader yet, but closed for deposit\\n        uint256 ongoingAsset; \\n        uint256 assetToTerminate;  \\n        uint256 assetToTerminateForNextRound;   \\n        uint232 totalRound; \\n        bool hasState;\\n    }\\n\\n    struct OptionSnapshot {\\n        uint256 totalPending;\\n        uint256 totalLocked;\\n        uint256 totalReleasedDeposit;\\n        uint256 totalReleasedCounterParty; \\n    }\\n\\n    struct UserBalance {\\n        uint256 pendingDepositAssetAmount; \\n        uint256 lockedDepositAssetAmount;  \\n        uint256 releasedDepositAssetAmount;\\n        uint256 releasedCounterPartyAssetAmount;\\n    }\\n\\n \\n\\n    function deriveWithdrawRequest(UserState memory userState, uint256 premiumRate) internal pure returns (uint256 _onGoingRoundAmount, uint256 _lockedRoundAmount) {\\n       if (userState.tempLocked == 0) {\\n           return (userState.assetToTerminateForNextRound, 0);\\n       }\\n       uint256 onGoing = userState.ongoingAsset;\\n       if (onGoing == 0) {\\n           return (0, userState.assetToTerminateForNextRound);\\n       }\\n       onGoing = onGoing.sub(userState.assetToTerminate);\\n       uint256 virtualOnGoing = onGoing.withPremium(premiumRate);\\n       if (userState.assetToTerminateForNextRound <= virtualOnGoing) {\\n           return (userState.assetToTerminateForNextRound, 0);\\n       }\\n       else {\\n           return (virtualOnGoing, userState.assetToTerminateForNextRound.sub(virtualOnGoing));\\n       }\\n    }\\n    function deriveVirtualLocked(UserState memory userState, uint256 premiumRate) internal pure returns (uint256) {\\n        uint256 onGoing = userState.ongoingAsset;\\n        if (onGoing == 0) {\\n            return userState.tempLocked;\\n        }\\n        onGoing = onGoing.sub(userState.assetToTerminate);\\n        if (userState.tempLocked == 0) {\\n            return onGoing.withPremium(premiumRate);\\n        }\\n        return userState.tempLocked.add(onGoing.withPremium(premiumRate));\\n        \\n    }\\n\\n       \\n     function calculateMaturity(bool _execute, StructureData.OptionState memory _optionState, bool _callOrPut, \\n     uint8 _depositAssetAmountDecimals, uint8 _counterPartyAssetAmountDecimals) internal pure\\n     returns(StructureData.MaturedState memory) {\\n       StructureData.MaturedState memory state = StructureData.MaturedState({\\n          releasedDepositAssetAmount: 0,\\n          releasedDepositAssetPremiumAmount: 0,\\n          autoRollDepositAssetAmount: 0,\\n          autoRollDepositAssetPremiumAmount: 0,\\n          releasedCounterPartyAssetAmount: 0, \\n          releasedCounterPartyAssetPremiumAmount: 0,\\n          autoRollCounterPartyAssetAmount: 0,\\n          autoRollCounterPartyAssetPremiumAmount: 0,\\n          round: _optionState.round\\n       });  \\n        if (_execute) {  \\n\\n           uint256 maturedCounterPartyAssetAmount = _callOrPut ? \\n            _optionState.totalAmount.mul(_optionState.strikePrice).mul(10**_counterPartyAssetAmountDecimals).\\n           div(10**(_optionState.pricePrecision + _depositAssetAmountDecimals))  :  \\n\\n           _optionState.totalAmount.mul(10**(_optionState.pricePrecision + _counterPartyAssetAmountDecimals)).\\n           div(_optionState.strikePrice).div(10** _depositAssetAmountDecimals); \\n \\n           uint256 maturedCounterPartyAssetPremiumAmount = maturedCounterPartyAssetAmount.premium(_optionState.premiumRate); \\n           if (_optionState.totalTerminate > 0) { \\n               state.releasedCounterPartyAssetAmount = Utils.getAmountToTerminate(maturedCounterPartyAssetAmount, _optionState.totalTerminate, _optionState.totalAmount);\\n               state.releasedCounterPartyAssetPremiumAmount = Utils.getAmountToTerminate(maturedCounterPartyAssetPremiumAmount, _optionState.totalTerminate, _optionState.totalAmount);\\n           }\\n           state.autoRollCounterPartyAssetAmount = maturedCounterPartyAssetAmount.sub(state.releasedCounterPartyAssetAmount);\\n           state.autoRollCounterPartyAssetPremiumAmount = maturedCounterPartyAssetPremiumAmount.sub(state.releasedCounterPartyAssetPremiumAmount);\\n        }\\n        else { \\n           uint256 maturedDepositAssetAmount = _optionState.totalAmount;\\n           uint256 maturedDepositAssetPremiumAmount = maturedDepositAssetAmount.premium(_optionState.premiumRate);\\n           if (_optionState.totalTerminate > 0) { \\n               state.releasedDepositAssetAmount = Utils.getAmountToTerminate(maturedDepositAssetAmount, _optionState.totalTerminate, _optionState.totalAmount);\\n               state.releasedDepositAssetPremiumAmount = Utils.getAmountToTerminate(maturedDepositAssetPremiumAmount, _optionState.totalTerminate, _optionState.totalAmount);\\n           }\\n           state.autoRollDepositAssetAmount = maturedDepositAssetAmount.sub(state.releasedDepositAssetAmount);\\n           state.autoRollDepositAssetPremiumAmount = maturedDepositAssetPremiumAmount.sub(state.releasedDepositAssetPremiumAmount);\\n\\n        }\\n         return state;\\n     }\\n\\n\\n    struct OptionPairDefinition{\\n        address callOption;\\n        address putOption;\\n        address callOptionDeposit;\\n        address putOptionDeposit;\\n    }\\n    struct SettlementAccountingResult {\\n        uint256 round;\\n        uint256 depositAmount;  \\n        uint256 autoRollAmount; //T-1 Carried (filled only when not executed)\\n        uint256 autoRollPremium; //Premium (filled only when not executed)\\n        //maturedAmount+maturedPremium = requested withdrawal for deposit asset(filled only when not executed and with withdraw request)\\n        uint256 releasedAmount;  \\n        uint256 releasedPremium;\\n        //autoRollCounterPartyAmount + autoRollCounterPartyPremium = Execution rolled-out for deposit asset (Execution roll-in for counter party option)\\n        //filled only when executed\\n        uint256 autoRollCounterPartyAmount;\\n        uint256 autoRollCounterPartyPremium;\\n        //maturedCounterPartyAmount+maturedCounterPartyPremium= requested withdrawal for couter party asset(filled only when executed and with withdraw request)\\n        uint256 releasedCounterPartyAmount;\\n        uint256 releasedCounterPartyPremium; \\n \\n        address option; \\n        bool executed;\\n\\n    }\\n\\n    enum OptionExecution{\\n        NoExecution,\\n        ExecuteCall,\\n        ExecutePut\\n    }\\n\\n    struct OptionPairExecutionAccountingResult {  \\n        SettlementAccountingResult callOptionResult;\\n        SettlementAccountingResult putOptionResult;\\n        OptionExecution execute;\\n    }\\n\\n    struct OptionPairExecution {\\n        address callOption;\\n        address putOption;\\n        OptionExecution execute; \\n    }\\n\\n    \\n\\n    struct SettlementCashflowResult{ \\n        uint256 newDepositAmount;\\n        uint256 newReleasedAmount;\\n        int256 leftOverAmount; //positive, if trader didn't withdraw last time; negative, if trader failed to send back last time; \\n        address contractAddress; //0 for eth \\n    }\\n \\n}\",\"keccak256\":\"0x730e719eaeb89d7e4ec73b3e3357c4a6e1c0d6f9066f3f59919ea38010342d0b\",\"license\":\"MIT\"},\"contracts/libraries/Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nlibrary Utils { \\n     \\n \\n      uint256 public constant RATIOMULTIPLIER = 10000;\\n     using SafeMath for uint256;\\n      function StringConcat(bytes memory _base, bytes memory _value) internal pure returns (string memory) {\\n        string memory _tmpValue = new string(_base.length + _value.length);\\n        bytes memory _newValue = bytes(_tmpValue);\\n\\n        uint i;\\n        uint j;\\n\\n        for(i=0; i<_base.length; i++) {\\n            _newValue[j++] = _base[i];\\n        }\\n\\n        for(i=0; i<_value.length; i++) {\\n            _newValue[j++] = _value[i++];\\n        }\\n\\n        return string(_newValue);\\n    }\\n\\n    function Uint8Sub(uint8 a, uint8 b) internal pure returns (uint8) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n \\n   function getAmountToTerminate(uint256 _maturedAmount, uint256 _assetToTerminate, uint256 _assetAmount) internal pure returns(uint256) {\\n       if (_assetToTerminate == 0 || _assetAmount == 0 || _maturedAmount == 0) return 0;\\n       return _assetToTerminate >= _assetAmount ?  _maturedAmount : _maturedAmount.mul(_assetToTerminate).div(_assetAmount);\\n   }\\n\\n   function withPremium(uint256 _baseAmount, uint256 _premimumRate) internal pure returns(uint256) {\\n       return _baseAmount.mul(RATIOMULTIPLIER.add(_premimumRate)).div(RATIOMULTIPLIER);\\n   }\\n   \\n   function premium(uint256 _baseAmount, uint256 _premimumRate) internal pure returns(uint256) {\\n       return _baseAmount.mul(_premimumRate).div(RATIOMULTIPLIER);\\n   }\\n   \\n\\n}\",\"keccak256\":\"0x6bae4b85176e81817159abf8d873b71c7df35bdf7ba35f3991e992045d408467\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60f9610039600b82828239805160001a60731461002c57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361060475760003560e01c806347276abf14604c5780637445e85c146085578063f747e1771460ab575b600080fd5b60727ffd0eee74c7609b4290ae42cfa22435eabf285017ea12017ed27c2e820eae6a7781565b6040519081526020015b60405180910390f35b60727f6666bf5bfee463d10a7fc50448047f8a53b7762d7e28fbc5c643182785f3fd3f81565b60b2600181565b60405160ff9091168152602001607c56fea2646970667358221220208ccb9fa9af5a71444461c317cbab39229a7052f8d080acf732cdca3a4d471964736f6c63430008040033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361060475760003560e01c806347276abf14604c5780637445e85c146085578063f747e1771460ab575b600080fd5b60727ffd0eee74c7609b4290ae42cfa22435eabf285017ea12017ed27c2e820eae6a7781565b6040519081526020015b60405180910390f35b60727f6666bf5bfee463d10a7fc50448047f8a53b7762d7e28fbc5c643182785f3fd3f81565b60b2600181565b60405160ff9091168152602001607c56fea2646970667358221220208ccb9fa9af5a71444461c317cbab39229a7052f8d080acf732cdca3a4d471964736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}